// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: leaderboards.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLeaderboard = `-- name: CreateLeaderboard :one
INSERT INTO leaderboards(
        name,
        name_language,
        description,
        description_language,
        cover_image_url,
        allow_anonymous,
        require_verification,
        unique_submission,
        creator
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, 
  name,
  description,
  created_at,
  updated_at,
  cover_image_url,
  allow_anonymous,
  require_verification,
  unique_submission,
  creator
`

type CreateLeaderboardParams struct {
	Name                string
	NameLanguage        string
	Description         string
	DescriptionLanguage string
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
}

type CreateLeaderboardRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
}

func (q *Queries) CreateLeaderboard(ctx context.Context, arg CreateLeaderboardParams) (CreateLeaderboardRow, error) {
	row := q.db.QueryRow(ctx, createLeaderboard,
		arg.Name,
		arg.NameLanguage,
		arg.Description,
		arg.DescriptionLanguage,
		arg.CoverImageUrl,
		arg.AllowAnonymous,
		arg.RequireVerification,
		arg.UniqueSubmission,
		arg.Creator,
	)
	var i CreateLeaderboardRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CoverImageUrl,
		&i.AllowAnonymous,
		&i.RequireVerification,
		&i.UniqueSubmission,
		&i.Creator,
	)
	return i, err
}

const deleteLeaderboard = `-- name: DeleteLeaderboard :exec
DELETE FROM leaderboards
WHERE id = $1
`

func (q *Queries) DeleteLeaderboard(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLeaderboard, id)
	return err
}

const getFavoriteLeaderboards = `-- name: GetFavoriteLeaderboards :many
SELECT l.id, 
    l.name,
    l.description,
    l.created_at,
    l.updated_at,
    l.cover_image_url,
    l.allow_anonymous,
    l.require_verification,
    l.unique_submission,
    l.creator,
    COUNT(le.*) AS entries_count
FROM leaderboards l
    INNER JOIN leaderboard_favourites f ON f.leaderboard_id = l.id
    LEFT JOIN leaderboard_entries le ON l.id = le.leaderboard_id
WHERE f.user_id = $1 AND l.created_at < $2
GROUP BY l.id,
    l.name,
    l.description,
    l.cover_image_url,
    l.created_at
ORDER BY l.created_at DESC
LIMIT $3
`

type GetFavoriteLeaderboardsParams struct {
	UserID    int32
	CreatedAt pgtype.Timestamptz
	Limit     int32
}

type GetFavoriteLeaderboardsRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
	EntriesCount        int64
}

func (q *Queries) GetFavoriteLeaderboards(ctx context.Context, arg GetFavoriteLeaderboardsParams) ([]GetFavoriteLeaderboardsRow, error) {
	rows, err := q.db.Query(ctx, getFavoriteLeaderboards, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavoriteLeaderboardsRow
	for rows.Next() {
		var i GetFavoriteLeaderboardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageUrl,
			&i.AllowAnonymous,
			&i.RequireVerification,
			&i.UniqueSubmission,
			&i.Creator,
			&i.EntriesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboardById = `-- name: GetLeaderboardById :one
SELECT id, name, description, created_at, updated_at, cover_image_url, allow_anonymous, require_verification, unique_submission, creator
FROM leaderboards
WHERE id = $1
`

type GetLeaderboardByIdRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
}

func (q *Queries) GetLeaderboardById(ctx context.Context, id int32) (GetLeaderboardByIdRow, error) {
	row := q.db.QueryRow(ctx, getLeaderboardById, id)
	var i GetLeaderboardByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CoverImageUrl,
		&i.AllowAnonymous,
		&i.RequireVerification,
		&i.UniqueSubmission,
		&i.Creator,
	)
	return i, err
}

const getLeaderboardFull = `-- name: GetLeaderboardFull :many
SELECT l.id, 
    l.name,
    l.description,
    l.created_at,
    l.updated_at,
    l.cover_image_url,
    l.allow_anonymous,
    l.require_verification,
    l.unique_submission,
    l.creator,
    lf.lid AS field_lid,
    lf.field_name,
    lf.field_value,
    lf.field_order,
    lf.for_rank AS field_for_rank,
    lf.hidden AS field_hidden,
    lf.required AS field_required,
    lel.id AS link_id,
    lel.leaderboard_id AS link_lid,
    lel.display_value AS link_display_value,
    lel.url AS link_url
from leaderboards l
    LEFT JOIN leaderboard_fields lf ON l.id = lf.lid
    LEFT JOIN leaderboard_external_links lel ON l.id = lel.leaderboard_id
WHERE l.id = $1
`

type GetLeaderboardFullRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
	FieldLid            pgtype.Int4
	FieldName           pgtype.Text
	FieldValue          NullFieldType
	FieldOrder          pgtype.Int4
	FieldForRank        pgtype.Bool
	FieldHidden         pgtype.Bool
	FieldRequired       pgtype.Bool
	LinkID              pgtype.Int4
	LinkLid             pgtype.Int4
	LinkDisplayValue    pgtype.Text
	LinkUrl             pgtype.Text
}

func (q *Queries) GetLeaderboardFull(ctx context.Context, id int32) ([]GetLeaderboardFullRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboardFull, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardFullRow
	for rows.Next() {
		var i GetLeaderboardFullRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageUrl,
			&i.AllowAnonymous,
			&i.RequireVerification,
			&i.UniqueSubmission,
			&i.Creator,
			&i.FieldLid,
			&i.FieldName,
			&i.FieldValue,
			&i.FieldOrder,
			&i.FieldForRank,
			&i.FieldHidden,
			&i.FieldRequired,
			&i.LinkID,
			&i.LinkLid,
			&i.LinkDisplayValue,
			&i.LinkUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboardsByUsername = `-- name: GetLeaderboardsByUsername :many
SELECT l.id, 
    l.name,
    l.description,
    l.created_at,
    l.updated_at,
    l.cover_image_url,
    l.allow_anonymous,
    l.require_verification,
    l.unique_submission,
    l.creator,
    COUNT(le.*) AS entries_count
FROM leaderboards l 
    LEFT JOIN users u ON u.id = l.creator
    LEFT JOIN leaderboard_entries le ON l.id = le.leaderboard_id
WHERE u.username = $1 AND l.created_at < $2
GROUP BY l.id,
    l.name,
    l.description,
    l.cover_image_url,
    l.created_at
ORDER BY l.created_at DESC
LIMIT $3
`

type GetLeaderboardsByUsernameParams struct {
	Username  string
	CreatedAt pgtype.Timestamptz
	Limit     int32
}

type GetLeaderboardsByUsernameRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
	EntriesCount        int64
}

func (q *Queries) GetLeaderboardsByUsername(ctx context.Context, arg GetLeaderboardsByUsernameParams) ([]GetLeaderboardsByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboardsByUsername, arg.Username, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardsByUsernameRow
	for rows.Next() {
		var i GetLeaderboardsByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageUrl,
			&i.AllowAnonymous,
			&i.RequireVerification,
			&i.UniqueSubmission,
			&i.Creator,
			&i.EntriesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLeaderboards = `-- name: GetRecentLeaderboards :many
SELECT l.id, 
    l.name,
    l.description,
    l.created_at,
    l.updated_at,
    l.cover_image_url,
    l.allow_anonymous,
    l.require_verification,
    l.unique_submission,
    l.creator,
    COUNT(le.*) AS entries_count
FROM leaderboards l
    LEFT JOIN leaderboard_entries le ON l.id = le.leaderboard_id
WHERE l.created_at < $1
GROUP BY l.id,
    l.name,
    l.description,
    l.cover_image_url,
    l.created_at
ORDER BY l.created_at DESC
LIMIT $2
`

type GetRecentLeaderboardsParams struct {
	CreatedAt pgtype.Timestamptz
	Limit     int32
}

type GetRecentLeaderboardsRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
	EntriesCount        int64
}

func (q *Queries) GetRecentLeaderboards(ctx context.Context, arg GetRecentLeaderboardsParams) ([]GetRecentLeaderboardsRow, error) {
	rows, err := q.db.Query(ctx, getRecentLeaderboards, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentLeaderboardsRow
	for rows.Next() {
		var i GetRecentLeaderboardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageUrl,
			&i.AllowAnonymous,
			&i.RequireVerification,
			&i.UniqueSubmission,
			&i.Creator,
			&i.EntriesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFavoriteLeaderboards = `-- name: SearchFavoriteLeaderboards :many
SELECT l.id,
    l.name,
    l.description,
    l.created_at,
    l.updated_at,
    l.cover_image_url,
    l.allow_anonymous,
    l.require_verification,
    l.unique_submission,
    l.creator,
    COUNT(le.*) AS entries_count,
    ts_rank_cd(l.search_tsv, websearch_to_tsquery(($3::text)::regconfig, $4)) AS rank
FROM leaderboards l
    INNER JOIN leaderboard_favourites f ON f.leaderboard_id = l.id
    LEFT JOIN leaderboard_entries le ON l.id = le.leaderboard_id
WHERE f.user_id = $1
GROUP BY l.id
HAVING ts_rank_cd(l.search_tsv, websearch_to_tsquery(($3::text)::regconfig, $4)) < $5::float4
ORDER BY rank DESC
LIMIT $2
`

type SearchFavoriteLeaderboardsParams struct {
	UserID     int32
	Limit      int32
	Language   string
	Query      string
	RankCursor float32
}

type SearchFavoriteLeaderboardsRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
	EntriesCount        int64
	Rank                float32
}

func (q *Queries) SearchFavoriteLeaderboards(ctx context.Context, arg SearchFavoriteLeaderboardsParams) ([]SearchFavoriteLeaderboardsRow, error) {
	rows, err := q.db.Query(ctx, searchFavoriteLeaderboards,
		arg.UserID,
		arg.Limit,
		arg.Language,
		arg.Query,
		arg.RankCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchFavoriteLeaderboardsRow
	for rows.Next() {
		var i SearchFavoriteLeaderboardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageUrl,
			&i.AllowAnonymous,
			&i.RequireVerification,
			&i.UniqueSubmission,
			&i.Creator,
			&i.EntriesCount,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLeaderboards = `-- name: SearchLeaderboards :many
SELECT l.id, 
    l.name,
    l.description,
    l.created_at,
    l.updated_at,
    l.cover_image_url,
    l.allow_anonymous,
    l.require_verification,
    l.unique_submission,
    l.creator,
    COUNT(le.*) AS entries_count,
    ts_rank_cd(l.search_tsv, websearch_to_tsquery(($2::text)::regconfig, $3)) AS rank
FROM leaderboards l
    LEFT JOIN leaderboard_entries le ON l.id = le.leaderboard_id
GROUP BY l.id
HAVING ts_rank_cd(l.search_tsv, websearch_to_tsquery(($2::text)::regconfig, $3)) < $4::float4
ORDER BY rank DESC
LIMIT $1
`

type SearchLeaderboardsParams struct {
	Limit      int32
	Language   string
	Query      string
	RankCursor float32
}

type SearchLeaderboardsRow struct {
	ID                  int32
	Name                string
	Description         string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	CoverImageUrl       pgtype.Text
	AllowAnonymous      bool
	RequireVerification bool
	UniqueSubmission    bool
	Creator             int32
	EntriesCount        int64
	Rank                float32
}

func (q *Queries) SearchLeaderboards(ctx context.Context, arg SearchLeaderboardsParams) ([]SearchLeaderboardsRow, error) {
	rows, err := q.db.Query(ctx, searchLeaderboards,
		arg.Limit,
		arg.Language,
		arg.Query,
		arg.RankCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLeaderboardsRow
	for rows.Next() {
		var i SearchLeaderboardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageUrl,
			&i.AllowAnonymous,
			&i.RequireVerification,
			&i.UniqueSubmission,
			&i.Creator,
			&i.EntriesCount,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
